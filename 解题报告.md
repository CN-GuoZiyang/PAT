### 1001 A+B Format (20分)

格式化字符串，要求隔三位按逗号分隔。

使用`std::to_string`可将数字转化为字符串，在输出时可直接将字符串看作和C一样的字符出租按下标索引。

输出时注意到，除却负号和最后一个字符外，每一个len-i模3余1的字符后都需要输出逗号。

```cpp
#include <cstdio>
#include <string>
using namespace std;

int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    string sumStr = to_string(a + b);
    int len = sumStr.length();
    for(int i = 0; i < len; i ++)
    {
        printf("%c", sumStr[i]);
        if(sumStr[i] == '-') continue;
        if((len - i)%3 == 1 && i != len - 1) printf(",");
    }
    return 0;
}
```

### 1002 A+B for Polynomials

这题用cpp重写之后不知道为什么写复杂了……

将两个多项式相加，Java党很自然地想到使用HashMap，C++里的map是基于红黑树的，查询速度也很快！

由于输出的时候需要按照指数排序，也就是按照map的key从大到小排序，而map是个无序的集合，所以需要将map转存在vector里，vector是动态数组。map里的每一个元素为一个pair，如map\<int, double\>的元素就说pair\<int, double\>，转存在vector后即可使用`std::sort`进行排序。每一个pair的first就是键，second就是值。

需要注意的是，使用`std::sort`排序的时候，需要导入`algorithm`包。在我的mac下使用g++时无需导包，但是PAT会编译错误。

另外，在判断double数值是否为0时需要引入误差，还需要首先计算绝对值再和误差比较。注意注意！

```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int cmp(pair<int, double> &a, pair<int, double> &b)
{
    return a.first > b.first;
}

int main()
{
    map<int, double> exps;
    for(int i = 0; i < 2; i ++)
    {
        int n;
        scanf("%d", &n);
        for(int j = 0; j < n; j ++)
        {
            int exp; double co;
            scanf("%d %lf", &exp, &co);
            if(exps.find(exp) != exps.end()) {
                exps[exp] += co;
            } else {
                exps[exp] = co;
            }
        }
    }
    vector<pair<int, double> > vecs(exps.begin(), exps.end());
    sort(vecs.begin(), vecs.end(), cmp);
    int len = 0;
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) len ++;
    }
    printf("%d", len);
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) printf(" %d %.1f", vecs[i].first, vecs[i].second);
    }
    return 0;
}
```

### 1003 Emergency (25分)

这一题涉及了深搜，但是柳神貌似是用Dijkstra做的，有空可以看看Dijkstra怎么寻找多条最短路径吧。

深搜就比较简单了，无脑暴力搜索即可。注意点在于在从某个节点退出的时候，记得减去路径长度和救援队数。

最后一个测试点如果直接搜索的话时间可能较长，用c++没有超时（154ms，又不是不能用），用Java之类的估计就超了，可以考虑剪枝，遍历到加上路径长度大于当前最小路径长度的节点的时候直接跳过，这样可以把时间减到7ms。

```cpp
#include <cstdio>
#include <vector>
#include <climits>
#include <algorithm>

using namespace std;

int n, m, c1, c2;
vector<int> teams;
vector<bool> visited(500, false);
int road[500][500];

int paths = 0;
int length = INT_MAX;
int tmpLength = 0;
int res = -1;
int tmpRes = 0;

void dfs(int start)
{
    tmpRes += teams[start];
    if(start == c2)
    {
        if(tmpLength < length)
        {
            length = tmpLength;
            paths = 1;
            res = tmpRes;
        } else if(tmpLength == length)
        {
            paths ++;
            if(tmpRes > res) res = tmpRes;
        }
        tmpRes -= teams[start];
        return;
    }
    visited[start] = true;
    for(int i = 0; i < n; i ++)
    {
        if(visited[i] == false && road[start][i] != 0)
        {
            tmpLength += road[start][i];
            if(tmpLength > length)
            {
                tmpLength -= road[start][i];
                continue;
            }
            dfs(i);
            tmpLength -= road[start][i];
        }
    }
    visited[start] = false;
    tmpRes -= teams[start];
    return;
}

int main()
{
    scanf("%d %d %d %d", &n, &m, &c1, &c2);
    for(int i = 0; i < n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        teams.push_back(tmp);
    }
    for(int i = 0; i < m; i ++)
    {
        int a, b, l;
        scanf("%d %d %d", &a, &b, &l);
        road[a][b] = l;
        road[b][a] = l;
    }
    dfs(c1);
    printf("%d %d", paths, res);
    return 0;
}
```

### 1004 Counting Leaves (30分)

主要是树的层序遍历，可以使用队列queue，也可以自己写数组模拟队列。

注意一下，各个容器（如vector和queue）中的`empty()`方法不是清空该容器，而是返回一个bool值，用来判断该容器是否为空，这一点和Java很不一样。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int n, m;

struct node {
    vector<int> children;
};

int main()
{
    scanf("%d %d", &n, &m);
    vector<node> nodes(n+1);
    for(int i = 0; i < m; i ++)
    {
        int id, k;
        scanf("%d %d", &id, &k);
        for(int j = 0; j < k; j ++)
        {
            int tmp;
            scanf("%d", &tmp);
            nodes[id].children.push_back(tmp);
        }
    }
    queue<int> q;
    q.push(1);
    vector<int> reses;
    while(q.empty() == false)
    {
        vector<int> layer;
        while(q.size() != 0)
        {
            layer.push_back(q.front());
            q.pop();
        }
        int res = 0;
        for(int i = 0; i < layer.size(); i ++)
        {
            int index = layer[i];
            if(nodes[index].children.size() == 0)
            {
                res ++;
            } else {
                for(int j = 0; j < nodes[index].children.size(); j ++)
                {
                    q.push(nodes[index].children[j]);
                }
            }
        }
        reses.push_back(res);
    }
    for(int i = 0; i < reses.size(); i ++)
    {
        if(i == reses.size() - 1)
        {
            printf("%d", reses[i]);
        } else {
            printf("%d ", reses[i]);
        }
    }
    return 0;
}
```

### 1005 Spell It Right (20分)

总体是个水题，主要就是考察一下输入输出和字符串的运用，比较坑的是，所有的测试用例最后貌似都会有一个回车符，直接用`while(scanf("%c", &tmp) != EOF)`会读进去，得排除掉。

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    char tmp;
    int sum = 0;
    while(scanf("%c", &tmp) != EOF)
    {
        if('0' <= tmp && tmp <= '9') sum += (tmp - '0');
    }
    string sumStr = to_string(sum);
    int len = sumStr.length();
    string numStr[] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
    cout << numStr[sumStr[0] - '0'];
    for(int i = 1; i < len; i ++)
    {
        cout << " " << numStr[sumStr[i] - '0'];
    }
    return 0;
}
```

### 1006 Sign In and Sign Out (25分)

水题，一边读一边把时间转成秒数，比较最后输出即可。

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    string in;
    int inTime = 23 * 3600 + 59 * 60 + 59 * 59;
    string out;
    int outTime = 0;
    for(int i = 0; i < n; i ++)
    {
        string tmp;
        int signin[3], signout[3];
        cin >> tmp;
        scanf("%d:%d:%d %d:%d:%d", &signin[0], &signin[1], &signin[2], &signout[0], &signout[1], &signout[2]);
        int signinSec = signin[0] * 3600 + signin[1] * 60 + signin[2];
        int signoutSec = signout[0] * 3600 + signout[1] * 60 + signout[2];
        if(signinSec < inTime) 
        {
            in = tmp;
            inTime = signinSec;
        }
        if(signoutSec > outTime)
        {
            out = tmp;
            outTime = signoutSec;
        }
    }
    cout << in << " " << out;
    return 0;
}
```

### 1007 Maximum Subsequence Sum (25分)

该题可以边读边判断。

记录一个临时的左侧和右侧坐标以及临时的和，不断读入新的数，如果读入的新的数让和小于0，就舍弃当前的临时值，将临时和置为0，并将临时左右侧放到下一个数的位置。否则就不断将数字读进来并与全局最大和对比，大于就更新。

对于全都是负数的情况，设置一个标志位并在最后判断标志即可。

```cpp
#include <cstdio>
#include <vector>

using namespace std;

int main()
{
    int k;
    scanf("%d", &k);
    int start=0, end=0, sum=-1;
    int tmpsum=0, tmpstart=0, tmpend=-1;
    bool allneg = true;
    vector<int> ints;
    for(int i = 0; i < k; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        ints.push_back(tmp);
        if(tmp >= 0) allneg = false;
        tmpsum += tmp;
        tmpend ++;
        if(tmpsum < 0)
        {
            tmpsum = 0;
            tmpstart = i+1;
            tmpend = i;
            continue;
        }
        if(tmpsum > sum)
        {
            start = tmpstart;
            end = tmpend;
            sum = tmpsum;
        }
    }
    if(allneg == true)
    {
        printf("0 %d %d", ints[0], ints[ints.size() - 1]);
        return 0;
    }
    printf("%d %d %d", sum, ints[start], ints[end]);
    return 0;
}
```

### 1008 Elevator (20分)

良心无坑水题，像是乙级的题目，唯一需要注意的是在每一层楼都需要停5秒，加上就行。

```cpp
#include <cstdio>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    int c = 0;
    int res = 0;
    for(int i = 0; i < n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        if(tmp == c) res += 5;
        else if(tmp > c)
        {
            res += ((tmp - c) * 6 + 5);
            c = tmp;
        } else
        {
            res += ((c - tmp) * 4 + 5);
            c = tmp;
        }
    }
    printf("%d", res);
    return 0;
}
```

### 1009 Product of Polynomials (25分)

该题类似于1002题，只不过变成了求多项式之积，基本思路一致。

多项式a可以先用一个map存储，待读入多项式b时，每读入一项就和多项式a逐项相乘，结果存入结果map中，再将结果map排序输出即可。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
#include <map>

using namespace std;

bool cmp(pair<int, double> a, pair<int, double> b)
{
    return a.first > b.first;
}

int main()
{
    map<int, double> pa;
    map<int, double> res;
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        int exp;
        double co;
        scanf("%d %lf", &exp, &co);
        pa[exp] = co;
    }
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        int exp;
        double co;
        scanf("%d %lf", &exp, &co);
        for(auto it = pa.begin(); it != pa.end(); it ++)
        {
            int tmp = exp + it->first;
            auto tmpit = res.find(tmp);
            if(tmpit != res.end())
            {
                res[tmp] = res[tmp] + it->second * co;
            } else {
                res[tmp] = it->second * co;
            }
        }
    }
    vector<pair<int, double> > resv(res.begin(), res.end());
    sort(resv.begin(), resv.end(), cmp);
    int num = 0;
    for(int i = 0; i < resv.size(); i ++)
    {
        if(abs(resv[i].second) > 0.05) num ++;
    }
    printf("%d", num);
    for(int i = 0; i < resv.size(); i ++)
    {
        if(abs(resv[i].second) > 0.05) printf(" %d %.1f", resv[i].first, resv[i].second);
    }
    return 0;
}
```

### 1010 Radix (25分)

这题**很坑**！

给出两个数和其中一个数的进制，要求找出另一个数的进制，使两个数相等。

主要方法就是二分，但是这个题的细节点很多。二分的下限是未知数中出现的最大的数字符号，上限就是另一个数，这个比较简单。

在二分的过程中可能会由于数字过大导致溢出，溢出的数字就会变成负数，得按照过大处理。

两个数使用long long表示，已知数的进制不是很大，可以用int表示，但是未知数的进制可能超过int的表示范围，需要用long long，否则会有一个测试点不通过。

这题二刷的时候才给整对……

```cpp
#include <string>
#include <iostream>
#include <cmath>

using namespace std;

long long convert2Decimal(string num, int radix)
{
    int power = 0;
    long long res = 0;
    int len = num.length();
    for(int i = len-1; i >= 0; i --, power ++)
    {
        int tmp;
        if('0' <= num[i] && num[i] <= '9')
        {
            tmp = num[i] - '0';
        } else {
            tmp = num[i] - 'a' + 10;
        }
        res += (pow(radix, power) * tmp);
    }
    return res;
}

int judgeEqual(long long s, string t)
{
    long long min = -1;
    int len = t.length();
    for(int i = 0; i < len; i ++)
    {
        char tmp = t[i];
        if(tmp > min) min = tmp;
    }
    if('0' <= min && min <= '9') min -= '0';
    else min = min - 'a' + 10;
    min ++;
    long long max = s < min ? min : s;
    while(min <= max)
    {
        long long mid = (min + max) / 2;
        long long tmp = convert2Decimal(t, mid);
        if(tmp < 0 || tmp > s) max = mid - 1;
        else if(tmp == s) return mid;
        else min = mid + 1;
    }
    return -1;
}

int main()
{
    int tag, radix;
    string n1, n2;
    cin >> n1 >> n2 >> tag >> radix;
    long long res = -1;
    if(tag == 1)
    {
        long long tmp = convert2Decimal(n1, radix);
        res = judgeEqual(tmp, n2);
    } else {
        long long tmp = convert2Decimal(n2, radix);
        res = judgeEqual(tmp, n1);
    }
    if(res == -1) cout << "Impossible";
    else cout << res;
    return 0;
}
```

### 1011 World Cup Betting (20分)

简单题。好像是关于球赛什么的，具体啥也没怎么读懂，反正读进去找最大值套公式就行。

找最大值可以使用`algorithm`包下的`max_element()`函数，传入头和尾的指针，返回指向最大值的指针，需要取值运算(\*)取出最大值。

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

int main()
{
    double res[3];
    int wtl[3];
    char duiying[] = {'W', 'T', 'L'};
    for(int i = 0; i < 3; i ++)
    {
        double a[3];
        for(int j = 0; j < 3; j ++) scanf("%lf", &a[j]);
        res[i] = *max_element(a, a+3);
        if(res[i] == a[0]) wtl[i] = 0;
        else if(res[i] == a[1]) wtl[i] = 1;
        else wtl[i] = 2;
    }
    for(int i = 0; i < 3; i ++)
    {
        printf("%c ", duiying[wtl[i]]);
    }
    printf("%.2f", (res[0] * res[1] * res[2] * 0.65 - 1) * 2);
    return 0;
}
```

### 1012 The Best Rank (25point(s))

简单题，获得最佳的排序，排序四次即可。

有一个坑在于并列的处理，显然，根据题意，并列情况应该处理为1、1、3、4、5，而不是1、1、2、3、4，更不是1、2、3、4、5。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

struct node {
    int id, best;
    int score[4], rank[4];
};

int exist[1000000], flag = -1;
bool cmp(node a, node b)
{
    return a.score[flag] > b.score[flag];
}
int main()
{
    int n, m, id;
    scanf("%d %d", &n, &m);
    vector<node> stu(n);
    for(int i = 0; i < n; i ++)
    {
        scanf("%d %d %d %d", &stu[i].id, &stu[i].score[1], &stu[i].score[2], &stu[i].score[3]);
        stu[i].score[0] = (stu[i].score[1] + stu[i].score[2] + stu[i].score[3]) / 3.0;
    }
    for(flag = 0; flag <= 3; flag ++)
    {
        sort(stu.begin(), stu.end(), cmp);
        stu[0].rank[flag] = 1;
        for(int i = 0; i < n; i ++)
        {
            stu[i].rank[flag] = i + 1;
            if(stu[i].score[flag] == stu[i - 1].score[flag])
            {
                stu[i].rank[flag] = stu[i-1].rank[flag];
            }
        }
    }
    for(int i = 0; i < n; i ++)
    {
        exist[stu[i].id] = i + 1;
        stu[i].best = 0;
        int minn = stu[i].rank[0];
        for(int j = 1; j <= 3; j ++)
        {
            if(stu[i].rank[j] < minn)
            {
                minn = stu[i].rank[j];
                stu[i].best = j;
            }
        }
    }
    char c[4] = {'A', 'C', 'M', 'E'};
    for(int i = 0; i < m; i ++)
    {
        scanf("%d", &id);
        int temp = exist[id];
        if(temp)
        {
            int best = stu[temp - 1].best;
            printf("%d %c\n", stu[temp-1].rank[best], c[best]);
        } else {
            printf("N/A\n");
        }
    }
    return 0;
}
```

### 1013 Battle Over Cities (25分)

深搜。

描述的是在一个连通图内，去掉一个节点，至少需要增加多少条边才可以重新变为一个连通图。

实质上就是求一个不连通的图中连通分量的个数，在拥有n个连通分量的图中，至少需要增加n-1条边即可使其变为连通图。

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

int n, m, k, c;
int roads[1001][1001];

bool visited[1001];

void dfs(int start)
{
    visited[start] = true;
    for(int i = 1; i <= n; i ++)
    {
        if(visited[i] == false && roads[start][i] == 1 && i != c) dfs(i);
    }
    return;
}

int main()
{
    scanf("%d %d %d", &n, &m, &k);
    for(int i = 0; i < m; i ++)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        roads[a][b] = 1;
        roads[b][a] = 1;
    }
    int checked[k];
    for(int i = 0; i < k; i ++)
    {
        scanf("%d", &checked[i]);
    }
    for(int i = 0; i < k; i ++)
    {
        c = checked[i];
        fill(visited, visited+1001, false);
        int part = 0;
        for(int j = 1; j <= n; j ++)
        {
            if(visited[j] != true && j != c)
            {
                part ++;
                dfs(j);
            }
        }
        printf("%d\n", part - 1);
    }
}
```

### 1014 Waiting in Line (30分)

模拟题，模拟排队服务，不难，就是烦，主要是需要注意的细节有点多，题目长

要求输出每个客户的服务结束时间，但是如果在17:00之前无法开始服务，就得输出Sorry。

剩余的就相当于模拟一遍排队过程而已。

```cpp
#include <cstdio>
#include <algorithm>
#include <queue>

using namespace std;

int n, m, k, q;
int serviceTime[1001];
int res[1001], START_TIME=8*60, END_TIME=17*60;

struct window
{
    int firstEnd=8*60, lastEnd=8*60;
    queue<int> customs;
};

int main()
{
    scanf("%d %d %d %d", &n, &m, &k, &q);
    for(int i = 1; i <= k; i ++)
    {
        scanf("%d", &serviceTime[i]);
    }
    bool sorry[k+1];
    fill(sorry, sorry+k+1, false);
    int index = 1; // 当前服务到的序号
    vector<window> windows(n);
    for(int i = 0; i < m; i ++)
    {
        for(int j = 0; j < n; j ++) // window号
        {
            if(index <= k)
            {
                windows[j].customs.push(index);
                if(windows[j].lastEnd >= END_TIME) sorry[index] = true;
                windows[j].lastEnd += serviceTime[index];
                res[index] = windows[j].lastEnd;
                if(i == 0) windows[j].firstEnd = windows[j].lastEnd;
                index ++;
            }
        }
    }
    while(index <= k)
    {
        // 寻找结束时间最短的window
        int min = 0, minT = windows[0].firstEnd;
        for(int i = 1; i < n; i ++)
        {
            if(windows[i].firstEnd < minT)
            {
                min = i;
                minT = windows[i].firstEnd;
            }
        }
        windows[min].customs.pop();
        windows[min].firstEnd += (serviceTime[windows[min].customs.front()]);
        windows[min].customs.push(index);
        if(windows[min].lastEnd >= END_TIME) sorry[index] = true;
        windows[min].lastEnd += serviceTime[index];
        res[index] = windows[min].lastEnd;
        index ++;
    }
    for(int i = 0; i < q; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        if(sorry[tmp] == true) printf("Sorry\n");
        else printf("%02d:%02d\n", res[tmp]/60, res[tmp]%60);
    }
    return 0;
}
```

### 1015 Reversible Primes (20point(s))

这题题目不难，就是英文难理解。

实际上就是给出一个十进制数，如果它是素数且在给定进制下翻转后得到的十进制数还是素数，就输出Yes

素数的判断要注意一下，`pow()`函数的参数和返回值都是double类型，需要做类型转换

```cpp
#include <cstdio>
#include <string>
#include <cmath>
#include <algorithm>

using namespace std;

int reverseWithR(int s, int r)
{
    int res = 0, arr[100];
    int i = 0;
    while(s != 0)
    {
        arr[i] = s % r;
        s /= r;
        i ++;
    }
    for(int j = 0; j < i; j ++)
    {
        res = res * r + arr[j];
    }
    return res;
}

bool isPrime(int a)
{
    if(a < 2) return false;
    int mid = int(sqrt(a*1.0));
    for(int i = 2; i <= mid; i ++)
    {
        if(a % i == 0) return false;
    }
    return true;
}

int main()
{
    while(true)
    {
        int b, radix;
        scanf("%d", &b);
        if(b < 0) break;
        scanf("%d", &radix);
        if(isPrime(b) == false)
        {
            printf("No\n");
            continue;
        }
        int c = reverseWithR(b, radix);
        if(isPrime(c) == false)
        {
            printf("No\n");
        } else {
            printf("Yes\n");
        }
    }
    return 0;
}
```

### 1016 Phone Bills (25point(s))

模拟题，计算电话账单。不算很难，有点烦。

由于要求按照字母顺序排列结果，可以将记录vector按照name从小到大排序，相同的再按照time从小到大排序。将成对的记录捡出来后，就可以输出了。

有个技巧，时间可以表示为从当月开始到目标时间的分钟数，如果要计算账单，可以用结束时间的账单减去开始时间的账单。数组多开一个记录打一天电话的费用即可。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
#include <iostream>
#include <map>

using namespace std;

struct record
{
    string name;
    int time;   // minute
    int status; // 0-on, 1-off
};

int costs[25];
int month;

float getm(int a)
{
    float t = 0;
    t += (costs[24] * (a / (24*60)));
    int h = (a / 60) % 24;
    for(int i = 0; i < h; i ++)
    {
        t += (60 * costs[i]);
    }
    t += ((a % 60) * costs[h]);
    return t/100.0;
}

int cmp(record a, record b)
{
    if(a.name != b.name)
    {
        return a.name < b.name;
    } else {
        return a.time < b.time;
    }
}

int main()
{
    for(int i = 0; i < 24; i ++)
    {
        scanf("%d", &costs[i]);
        costs[24] += (costs[i] * 60);
    }
    int n;
    scanf("%d", &n);
    vector<record> recs(n);
    for(int i = 0; i < n; i ++)
    {
        cin >> recs[i].name;
        int mo, dd, hh, mm;
        scanf("%d:%d:%d:%d", &mo, &dd, &hh, &mm);
        month = mo;
        recs[i].time = dd * 60 * 24 + hh * 60 + mm;
        string status;
        cin >> status;
        if(status == "on-line") recs[i].status = 0;
        else recs[i].status = 1;
    }
    sort(recs.begin(), recs.end(), cmp);
    map<string, vector<record> > ress;
    for(int i = 0; i < recs.size()-1; i ++)
    {
        if(recs[i].name == recs[i+1].name && recs[i].status == 0 && recs[i+1].status == 1)
        {
            ress[recs[i].name].push_back(recs[i]);
            ress[recs[i].name].push_back(recs[i+1]);
        }
    }
    for(auto it : ress)
    {
        cout << it.first;
        printf(" %02d\n", month);
        vector<record> tmpv = it.second;
        float total = 0;
        for(int i = 0; i < tmpv.size(); i += 2)
        {
            int dda, hha, mma, ddb, hhb, mmb;
            dda = tmpv[i].time / (60 * 24);
            hha = (tmpv[i].time / 60) % 24;
            mma = tmpv[i].time % 60;
            ddb = tmpv[i+1].time / (60 * 24);
            hhb = (tmpv[i+1].time / 60) % 24;
            mmb = tmpv[i+1].time % 60;
            int time = tmpv[i+1].time-tmpv[i].time;
            float money = getm(tmpv[i+1].time) - getm(tmpv[i].time);
            total += money;
            printf("%02d:%02d:%02d %02d:%02d:%02d %d $%.2f\n", dda, hha, mma, ddb, hhb, mmb, time, money);
        }
        printf("Total amount: $%.2f\n", total);
    }
    return 0;
}
```

### 1017 Queueing at Bank (25分)

模拟题，类似1014，比1014简单。

也是银行排队的题目，只是只允许一个人站在黄线以内，而且所有人不是同时到的。

只需要将窗口的初始的结束当前服务的时间设置为8:00，将客户列表排个序，逐个判断即可。注意，超过17:00到达的顾客不算顾客，等待时间不应该加在总时间里，也不应该算在总顾客里。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

struct window
{
    int endTime = 8 * 60 * 60;
};

struct cu
{
    int aTime;
    int pTime;
};

bool cmp(cu a, cu b)
{
    return a.aTime < b.aTime;
};

int main()
{
    int n, k, res=0;
    scanf("%d %d", &n, &k);
    vector<window> windows(k);
    vector<cu> cus(n);
    for(int i = 0; i < n; i ++)
    {
        int hh, mm, ss, p;
        scanf("%d:%d:%d %d", &hh, &mm, &ss, &p);
        p *= 60;
        cus[i].aTime = hh * 3600 + mm * 60 + ss;
        cus[i].pTime = p;
    }
    sort(cus.begin(), cus.end(), cmp);
    int count = 0;
    for(int i = 0; i < n; i ++)
    {
        cu tmp = cus[i];
        if(tmp.aTime >= 17*3600 + 1) break;
        int minT = windows[0].endTime, min=0;
        for(int j = 1; j < k; j ++)
        {
            if(windows[j].endTime < minT)
            {
                min = j;
                minT = windows[j].endTime;
            }
        }
        if(tmp.aTime < minT)
        {
            res += (minT - tmp.aTime);
            windows[min].endTime += tmp.pTime;
        } else if(tmp.aTime == minT) {
            windows[min].endTime += tmp.pTime;
        } else {
            windows[min].endTime = tmp.aTime + tmp.pTime;
        }
        count ++;
    }
    float avg = res / 60.0 / count;
    printf("%.1f", avg);
    return 0;
}
```

### 1018 Public Bike Management (30point(s))

挺难一个题，主要是复杂。

柳神这一题用的是Dijkstra + dfs，只有Dijkstra肯定是不行的，最短路径也不只一条。但是由于我Dijkstra已经忘差不多了，所以只用了dfs + 剪枝来做，速度也不慢。

题目的坑点比较多，首先需要记录的是发出的个数和带回的个数，如果中间需要给站点补充单车而导致携带的数量小于0，就只能增加发出的个数，不能挪用之后站点的车。

还有一个坑点就是，题目要求如果路的长度相同，就应该选择发出个数最小的路，但是却没说，如果发出个数也都相同，就应该选择带回个数最小的路。如果忽略这个点，会导致最后三个测试点错误。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

vector<int> croad;
vector<int> rroad;
int csend = 0;
int rsend = INT_MAX;
int clength = 0;
int rlength = INT_MAX;
int rback=INT_MAX, cback = 0;
bool visit[501];
int road[501][501];
int cstatus[501];
int best, n;

void dfs(int start, int end)
{
    visit[start] = true;
    int lback = cback;
    int lsend = csend;
    cback += (cstatus[start] - best);
    if(cback < 0)
    {
        csend += (-cback);
        cback = 0;
    }
    if(start == end)
    {
        if(clength < rlength)
        {
            rlength = clength;
            rsend = csend;
            rback = cback;
            rroad.clear();
            rroad.assign(croad.begin(), croad.end());
        } else if(clength == rlength && csend < rsend)
        {
            rsend = csend;
            rback = cback;
            rroad.clear();
            rroad.assign(croad.begin(), croad.end());
        } else if(clength == rlength && csend == rsend && cback < rback)
        {
            rback = cback;
            rroad.clear();
            rroad.assign(croad.begin(), croad.end());
        }
        csend = lsend;
        cback = lback;
        visit[start] = false;
        return;
    }
    for(int i = 1; i <= n; i ++)
    {
        if(road[i][start] != 0 && visit[i] == false)
        {
            clength += road[i][start];
            if(clength > rlength)
            {
                clength -= road[i][start];
                continue;
            }
            croad.push_back(i);
            dfs(i, end);
            croad.pop_back();
            clength -= road[i][start];
        }
    }
    csend = lsend;
    cback = lback;
    visit[start] = false;
    return;
}

int main()
{
    int cm, sp, m;
    scanf("%d %d %d %d", &cm, &n, &sp, &m);
    best = cm / 2;
    cstatus[0] = best;
    for(int i = 1; i <= n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        cstatus[i] = tmp;
    }
    for(int i = 0; i < m; i ++)
    {
        int a, b, c;
        scanf("%d %d %d", &a, &b, &c);
        road[a][b] = c;
        road[b][a] = c;
    }
    dfs(0, sp);
    printf("%d 0", rsend);
    for(int i = 0; i < rroad.size(); i ++)
    {
        printf("->%d", rroad[i]);
    }
    printf(" %d", rback);
    return 0;
}
```

### 1019 General Palindromic Number (20分)

简单题，判断十进制数字在给定的进制下是否是回文数，转换后从两端遍历即可。

只需要注意一下输入为0的时候直接输出即可，无需转换。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

vector<int> res;

int main()
{
    int d, b;
    scanf("%d %d", &d, &b);
    if(d == 0)
    {
        printf("Yes\n0");
        return 0;
    }
    while(d != 0)
    {
        res.push_back(d%b);
        d /= b;
    }
    reverse(res.begin(), res.end());
    bool is = true;
    for(int i = 0, j = res.size()-1; i < j; i ++, j --)
    {
        if(res[i] != res[j])
        {
            is = false;
            break;
        }
    }
    if(is == true) printf("Yes\n");
    else printf("No\n");
    printf("%d", res[0]);
    for(int i = 1; i < res.size(); i ++)
    {
        printf(" %d", res[i]);
    }
    return 0;
}
```

### 1020 Tree Traversals (25分)

已知二叉树的后序遍历和中序遍历，给出层序遍历。

数据结构基础，后序遍历就是根，根就可以把中序遍历分为左子树和右子树，递归做就能构建成完整的树。层序遍历用队列即可，不算难。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
#include <queue>

using namespace std;

struct node
{
    int left, right;
};

int n, post[31], in[31];
vector<node> tree(31);

int build(vector<int> posto, vector<int> ino)
{
    if(posto.size() == 1) return posto[0];
    else if(posto.size() == 0) return -1;
    int root = posto[posto.size() - 1];
    int rootIndex = 0;
    for(rootIndex = 0; rootIndex < ino.size(); rootIndex ++)
    {
        if(ino[rootIndex] == root) break;
    }
    vector<int> leftin, rightin, leftpo, rightpo;
    leftin.assign(ino.begin(), ino.begin()+rootIndex);
    rightin.assign(ino.begin()+rootIndex+1, ino.end());
    for(int i = 0; i < posto.size(); i ++)
    {
        int tmp = posto[i];
        if(find(leftin.begin(), leftin.end(), tmp) != leftin.end()) leftpo.push_back(tmp);
        else if(find(rightin.begin(), rightin.end(), tmp) != rightin.end()) rightpo.push_back(tmp);
    }
    int left = build(leftpo, leftin);
    int right = build(rightpo, rightin);
    tree[root].left = left;
    tree[root].right = right;
    return root;
}

int main()
{
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        scanf("%d", &post[i]);
    }
    for(int i = 0; i < n; i ++)
    {
        scanf("%d", &in[i]);
    }
    vector<int> posto(post, post+n);
    vector<int> ino(in, in+n);
    int root = build(posto, ino);
    queue<int> cu;
    cu.push(root);
    printf("%d", root);
    while(cu.empty() == false)
    {
        int tmp = cu.front();
        cu.pop();
        if(tmp != root) printf(" %d", tmp);
        if(tree[tmp].left != -1 && tree[tmp].left != 0) cu.push(tree[tmp].left);
        if(tree[tmp].right != -1 && tree[tmp].right != 0) cu.push(tree[tmp].right);
    }
}
```

### 1021 Deepest Root (25分)

从图中找到深度最深的树，并输出根。

主要是运用图和树的知识。距离任意一点最远的点一定是一个deepest root。证明见[tenos](https://www.cnblogs.com/TenosDoIt/p/3401764.html)。于是实际上只需要dfs两个回合即可，第一次从任意一个点出发，记录最远点的集合，第二次从这个集合的任意点出发，再记录一个集合，两个集合的并就是答案。

题目要求如果是不连通图的话需要输出错误，于是第一次dfs可以顺便记录一下连通分量的个数。

最初没有使用两个集合的并，仅仅是用第二个集合加上了第二次的出发点，这样会导致测试点4和5不通过，因为两个Deepest Root之间的距离不一定最大。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

bool road[10001][10001];
bool visit[10001];

int n;
int height = 0;
int hh = -1;
vector<int> hnode;
bool first = true;

void dfs(int start)
{
    height ++;
    visit[start] = true;
    if(height > hh)
    {
        hh = height;
        hnode.clear();
        hnode.push_back(start);
    } else if(height == hh)
    {
        hnode.push_back(start);
    }
    for(int i = 1; i <= n; i ++)
    {
        if(road[start][i] == true && visit[i] == false)
        {
            dfs(i);
        }
    }
    height --;
    if(first == false) visit[start] = false;
    return;
}

bool cmp(int a, int b)
{
    return a < b;
}

int main()
{
    scanf("%d", &n);
    for(int i = 0; i < n-1; i ++)
    {
        int a, b;
        scanf("%d %d", &a, &b);
        road[a][b] = true;
        road[b][a] = true;
    }
    int con = 0;
    for(int i = 1; i <= n; i ++)
    {
        if(visit[i] == false)
        {
            dfs(i);
            con ++;
        }
    }
    if(con > 1)
    {
        printf("Error: %d components", con);
        return 0;
    }
    first = false;
    hh = -1;
    fill(visit, visit+10001, false);
    vector<int> tmp(hnode);
    dfs(hnode[0]);
    for(int i = 0; i < tmp.size(); i ++) hnode.push_back(tmp[i]);
    sort(hnode.begin(), hnode.end(), cmp);
    printf("%d\n", hnode[0]);
    for(int i = 1; i < hnode.size(); i ++)
    {
        if(hnode[i] == hnode[i-1]) continue;
        printf("%d\n", hnode[i]);
    }
    return 0;
}
```

### 1022 Digital Library (30point(s))

读入书籍数据，根据关键词查找并输出书籍ID。

这题做的就很让人生气，C++标准库对于字符串的无能在这一题里展现的淋漓尽致。

一次读入一行字符串的话使用`getline(cin, string)`函数，分割字符串可以使用getline函数，现将字符串转化为stringstream，`getline(stringstream, string, split)`，其中split是char分割符，getline将会在遇到分割符时停止，并存入string中，循环读即可实现字符串分割。char[]转为string的方法直接赋值即可。

其他的话，可以将关键字和id建为map，可以实现比较快速的查找。id应该存为string形式，否则测试点3和4会错误，估计id是012345的形式的。

```cpp
#include <cstdio>
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <sstream>

using namespace std;

map<string, vector<string> > books;

void push(string key, string id)
{
    auto it = books.find(key);
    if(it == books.end())
    {
        vector<string> tmp;
        tmp.push_back(id);
        books[key] = tmp;
    } else {
        it->second.push_back(id);
    }
}

int main()
{
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        string id;
        cin >> id;
        string tmp;
        getline(cin, tmp);
        push(id, id);
        string title, author, keys, publisher, year;
        getline(cin, title);
        push(title, id);
        getline(cin, author);
        push(author, id);
        getline(cin, keys);
        stringstream input(keys);
        string temp;
        while(getline(input, temp, ' '))
        {
            push(temp, id);
        }
        getline(cin, publisher);
        push(publisher, id);
        getline(cin, year);
        push(year, id);
    }
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        char key[100];
        int id;
        scanf("%d: %[^\n]", &id, key);
        printf("%d: %s\n", id, key);
        string keyword = key;
        auto it = books.find(keyword);
        if(it != books.end())
        {
            vector<string> tmp = it->second;
            sort(tmp.begin(), tmp.end());
            int len = tmp.size();
            for(int j = 0; j < len; j ++)
            {
                cout << tmp[j] << endl;
            }
        } else {
            printf("Not Found\n");
        }
    }
    return 0;
}
```

### 1023 Have Fun with Numbers (20分)

简单题，判断一个数乘以2后是否由构成原数的数字构成，并输出。

为了防止数字过大，可以用vector来存储一个数字的每一位，并对每一位乘以2并记录进位加到下一位。用一个map来存储原数的数字使用情况，来和乘二后的数对比即可。

```cpp
#include <vector>
#include <algorithm>
#include <cstdio>
#include <map>

using namespace std;

int main()
{
    char tmp;
    map<int, int> countb;
    for(int i = 0; i < 10; i ++)
    {
        countb[i] = 0;
    }
    vector<int> b;
    while(true)
    {
        tmp = getchar();
        if('0' <= tmp && tmp <= '9')
        {
            b.push_back(tmp - '0');
            countb[tmp-'0'] ++;
        } else {
            break;
        }
    }
    int jinwei = 0;
    bool Yes = true;
    for(int i = b.size()-1; i >= 0; i --)
    {
        int tmp = b[i] * 2 + jinwei;
        if(tmp >= 10)
        {
            b[i] = tmp % 10;
            jinwei = 1;
        } else {
            b[i] = tmp;
            jinwei = 0;
        }
        countb[b[i]] --;
        if(countb[b[i]] < 0) Yes = false;
    }
    if(jinwei != 0)
    {
        countb[1] --;
        if(countb[1] < 0) Yes = false;
    }
    for(int i = 0; i < 10; i ++)
    {
        if(countb[i] != 0) Yes = false;
    }
    if(Yes == false) printf("No\n");
    else printf("Yes\n");
    if(jinwei != 0) printf("%d", jinwei);
    for(int i = 0; i < b.size(); i ++)
    {
        printf("%d", b[i]);
    }
    return 0;
}
```

### 1024 Palindromic Number (25分)

回文数字判断，如果一个数字不是回文数，将原数加上原数的翻转，再判断是否是回文数，输出需要进行多少次这样的操作一个非回文数才会变成回文数。

题目不难，最开始需要先判断一下给定的数是否是回文数，如果是的话就相当于0次操作就是回文数了。另外，字符数组转字符串的时候最后一个元素一定要是`'\0'`，否则会有乱码。

```cpp
#include <string>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

bool test(string s)
{
    if(s.size() == 1) return true;
    int l=0, r=s.size()-1;
    while(l < r)
    {
        if(s[l] != s[r]) return false;
        l ++;
        r --;
    }
    return true;
}

string add(string a)
{
    string b = a;
    reverse(b.begin(), b.end());
    vector<char> resv;
    int len = a.length();
    int jinwei = 0;
    for(int i = len-1; i >= 0; i --)
    {
        int tmpa = a[i]-'0', tmpb = b[i]-'0';
        int res = tmpa + tmpb + jinwei;
        if(res >= 10)
        {
            res = res % 10;
            jinwei = 1;
        } else {
            jinwei = 0;
        }
        char tmp = res + '0';
        resv.push_back(tmp);
    }
    if(jinwei != 0) resv.push_back('1');
    reverse(resv.begin(), resv.end());
    char resc[resv.size()+1];
    for(int i = 0; i < resv.size(); i ++)
    {
        resc[i] = resv[i];
    }
    resc[resv.size()] = '\0';
    string rt = resc;
    return rt;
}

int main()
{
    string raw;
    int k;
    cin >> raw >> k;
    if(test(raw) == true) 
    {
        cout << raw << endl;
        cout << 0;
        return 0;
    }
    for(int i = 1; i <= k; i ++)
    {
        raw = add(raw);
        if(test(raw) == true)
        {
            cout << raw << endl;
            cout << i;
            return 0;
        }
    }
    cout << raw << endl;
    cout << k;
    return 0;
}
```

### 1025 PAT Ranking (25point(s))

先部分排序再整体排序，不难。

有一个小坑，最后一个测试点，要求输出的id为13位的整数，不满13位需要补零。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

struct node
{
    long long int id;
    int score, frank, lnum, lrank;
};

vector<node> final;

bool cmp1(node a, node b)
{
    if(a.score != b.score) return a.score > b.score;
    else return a.id < b.id;
}

int main()
{
    int n, k;
    scanf("%d", &n);
    for(int i = 1; i <= n; i ++)
    {
        scanf("%d", &k);
        vector<node> tmp(k);
        for(int j = 0; j < k; j ++)
        {
            scanf("%lld %d", &tmp[j].id, &tmp[j].score);
            tmp[j].lnum = i;
        }
        sort(tmp.begin(), tmp.end(), cmp1);
        tmp[0].lrank = 1;
        for(int j = 1; j < k; j ++)
        {
            if(tmp[j].score == tmp[j-1].score) tmp[j].lrank = tmp[j-1].lrank;
            else tmp[j].lrank = j+1;
        }
        final.insert(final.end(), tmp.begin(), tmp.end());
    }
    sort(final.begin(), final.end(), cmp1);
    final[0].frank = 1;
    for(int i = 1; i < final.size(); i ++)
    {
        if(final[i].score == final[i-1].score) final[i].frank = final[i-1].frank;
        else final[i].frank = i+1;
    }
    printf("%lu\n", final.size());
    for(int i = 0; i < final.size(); i ++)
    {
        printf("%013lld %d %d %d\n", final[i].id, final[i].frank, final[i].lnum, final[i].lrank);
    }
    return 0;
}
```

### 1026 Table Tennis (30point(s))

PAT模拟题史上最黑暗的一题，直接给我干吐了。佩服那些在考场上能直接AC的大佬。

坑点很多：

1. 当客户的使用时间超过2小时，按两小时算。
2. 当有空闲的VIP桌子和普通桌子时，VIP用户首先优先选择VIP桌，再选择编号小的。
3. 等待时间按分钟四舍五入

具体的逻辑在代码的注释中有体现，感谢[@6号楼下的大懒喵](https://blog.csdn.net/CV_Jason/article/details/84671066)

```cpp
#include<iostream>
#include<algorithm>
#include<vector> 

using namespace std;

struct member
{
	int arrivingTime;
	int playingTime;
	int vip;
	int waitingTime;
	int startTime; 
	int haveTable;
	int num;
};

struct table
{
	int endTime;
	int totalPeople;
	int vip; 
};

bool cmp(member a,member b)
{
	return a.arrivingTime<b.arrivingTime;
}

bool cmp2(member a,member b)
{
	return a.startTime<b.startTime;
}

vector<member> waitQueue;
table tables[101];

int main(){
	int N,M,K;
 	while(scanf("%d", &N)!=EOF)
     {
		for(int i=0;i<N;i++)
        {
			// 输入数据 
			member temp;
			int hh,mm,ss;
			scanf("%d:%d:%d%d%d",&hh,&mm,&ss,&temp.playingTime,&temp.vip);
			temp.arrivingTime = hh*3600+mm*60+ss;
			temp.playingTime = (temp.playingTime>120?120*60:temp.playingTime*60);
			temp.haveTable = -1;
			temp.startTime = 21*3600;
			temp.num = i+1;
			waitQueue.push_back(temp);
		}
		table initTable{8*3600,0,0};
		fill(tables,tables+101,initTable);
		scanf("%d%d",&K,&M);
		for(int i = 0; i < M; i ++)
        {
			int temp;
			scanf("%d",&temp);
			tables[temp-1].vip = 1;
		}
		sort(waitQueue.begin(),waitQueue.end(),cmp);
		/* -------------分配策略---------------*/		
		for(auto it = waitQueue.begin();it!=waitQueue.end();){
			// 分配第it个会员
			auto it_current = it;// it是遍历整个排队队列的主指针，it_current是临时指针，指向每一次遍历需要安排的会员 
			int min_endTime = 21*3600;// min_endTime 负责记录最早空闲出来的桌子的时间 
			int postion = 0;// postion记录最终分派的桌子的位置 
			bool novip = true;
			// 从K个桌子中遍历最早空闲的桌子，如果存在多个桌子，选择最小的那个 
			for(int i=0;i<K;i++){
				if(min_endTime>tables[i].endTime){
					postion = i;
					min_endTime = tables[i].endTime;
				}
			}
			if(tables[postion].endTime>=21*3600)// 如果最早空出来的桌子都超过了21点，显然此时任何一个桌子都不能再分配 
				break;
			// 选出合适的位置了之后，开始判断，先看桌子是不是VIP桌子，如果是，再看目前排队的人有没有VIP 
			if(tables[postion].vip){
				//【第一大类】最先空出来的桌子是VIP桌子，
				// 那么下一步判断在该桌子空闲的过程中，it_current身后排队的人群中有没有VIP，如果有，VIP优先于当前
				for(;it_current != waitQueue.end()&&it_current->arrivingTime<=min_endTime;it_current++){
					if(it_current->vip && it_current->haveTable==-1){
						//【1】 VIP桌子，存在到场的VIP会员，分配该桌子给VIP
						it_current->haveTable = postion;
						novip = false;
						break;// 此时it指针不能移动，因为可能vip在很后面的位置，如果移动，当前节点就会被跳过 ，标记该VIP已经被分配过即可 
					}
				} 
				if(novip){
					//【2】VIP桌子，但是不存在到场的VIP会员，那么分配给排队的第一个人 
					it_current = it;
					it_current->haveTable = postion;
					it++;
				}
			}else{//【第二大类】最先空出来的不是VIP桌 
				// 如果当前的会员不是VIP，非VIP球桌分配给非VIP会员，直接分配
				if(it_current->vip!=1){
					it_current->haveTable = postion;
					it++;
				}else{// 如果当前排队的是VIP，那么需要确认是否存在其他空闲的VIP桌子 
					int vipTable = -1;
					for(int i=0;i<K;i++){
						if(tables[i].vip&&tables[i].endTime<=it_current->arrivingTime){
							vipTable = i;
							break;
						}
					} 
					// 存在VIP空闲桌，那么给VIP分配VIP桌子 
					if(vipTable!=-1)
                    {
						it_current->haveTable = vipTable;
						postion = vipTable; 
					} else { 
						if(it_current->haveTable==-1) {
							it_current->haveTable = postion; 
							//cout<<"postion = "<<postion<<" num = "<<it_current->num<<endl;
						} else {
							it++;
							continue;
						}
					}
					it++;
				} 
			}
			// 更新会员数据，如果到的时候，是空闲的，那么以到的时间为开始时间，否则以桌子的空闲时间为开始时间 
			it_current->startTime = min_endTime>it_current->arrivingTime?min_endTime:it_current->arrivingTime;
			it_current->waitingTime = min_endTime<=it_current->arrivingTime? 0:min_endTime-it_current->arrivingTime;			
			// 更新桌子的数据，结束时间以当前使用者开始使用+使用时间为准 
			tables[postion].endTime = it_current->startTime+it_current->playingTime; 
			if(it_current->startTime<21*3600)
				tables[postion].totalPeople++;
		}
		/* -------------输出---------------*/
		sort(waitQueue.begin(),waitQueue.end(),cmp2);
		for(auto elem:waitQueue){
			if(elem.startTime>=21*3600) continue;
			int hh1 = elem.arrivingTime/3600;
			int mm1 = (elem.arrivingTime - hh1*3600)/60;
			int ss1 = elem.arrivingTime - mm1*60 - hh1*3600;
			int hh2 = elem.startTime/3600;
			int mm2 = (elem.startTime - hh2*3600)/60;
			int ss2 = elem.startTime - mm2*60 - hh2*3600;
			int waitingTime = elem.waitingTime/60 +((elem.waitingTime%60>=30)? 1:0);
			printf("%02d:%02d:%02d %02d:%02d:%02d %d\n",hh1,mm1,ss1,hh2,mm2,ss2,waitingTime);
		} 
		printf("%d",tables[0].totalPeople);
		for(int i=1;i<K;i++){
			printf(" %d",tables[i].totalPeople);
		}
	}
	return 0;
}
```

### 1027 Colors in Mars (20point(s))

简单题，给定三个十进制数，转化成三个13进制数，按照格式输出即可，注意补0。

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

char shisan[13]={'0','1','2','3','4','5','6','7','8','9','A','B','C'};

void convert(int a)
{
    char tmp[2] = {'0', '0'};
    int i = 1;
    while(a != 0)
    {
        tmp[i] = shisan[a % 13];
        a /= 13;
        i --;
    }
    for(i = 0; i < 2; i ++)
    {
        printf("%c", tmp[i]);
    }
}

int main()
{
    int dr, dg, db;
    scanf("%d %d %d", &dr, &dg, &db);
    printf("#");
    convert(dr);
    convert(dg);
    convert(db);
    return 0;
}
```

### 1028 List Sorting (25point(s))

简单题，给定一堆数据，按照某一列的标准排序。

对于如果给定属性相同的情况，题目说的有点模糊，实际上如果给定属性相同，就都按照id升序排。

```cpp
#include <vector>
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>

using namespace std;

struct s
{
    int num;
    string name;
    int grade;
};

int n, c;

bool cmp(s a, s b)
{
    if(c == 1)
    {
        return a.num < b.num;
    } else if(c == 2)
    {
        if(a.name != b.name) return a.name <= b.name;
        else return a.num < b.num;
    } else {
        if(a.grade != b.grade) return a.grade <= b.grade;
        else return a.num < b.num;
    }
}

int main()
{
    scanf("%d %d", &n, &c);
    vector<s> ss(n);
    for(int i = 0; i < n; i ++)
    {
        cin >> ss[i].num >> ss[i].name >> ss[i].grade;
    }
    sort(ss.begin(), ss.end(), cmp);
    for(int i = 0; i < n; i ++)
    {
        printf("%06d ", ss[i].num);
        cout << ss[i].name << " " << ss[i].grade << endl;
    }
    return 0;
}
```

### 1029 Median (25分)

较为简单，给出两组递增序列，输出两组序列排序后的中间数。

可以首先读进第一个序列，并计算出中间数的序号，第二个序列边读边直接处理，用一个指针指向第一个序列，保证指向的数比第二个序列正在读进来的数小即可，循环从两个序列中读，并记录读的个数，直到读到中间数后停止。如果读完第二个序列还没有读到中间数，说明该数存在于第一个序列中，继续读第一个序列即可。

```cpp
#include <cstdio>
#include <vector>

using namespace std;

int main()
{
    int an, bn;
    scanf("%d", &an);
    vector<long> a(an);
    for(int i = 0; i < an; i ++)
    {
        scanf("%ld", &a[i]);
    }
    scanf("%d", &bn);
    int midIndex = (an+bn+1)/2;
    int ai = 0;
    int ci = 0;
    for(int i = 0; i < bn; i ++)
    {
        long tmpd;
        scanf("%ld", &tmpd);
        if(ai < an && a[ai] < tmpd)
        {
            while(a[ai] < tmpd)
            {
                ci ++;
                if(ci == midIndex)
                {  
                    printf("%ld", a[ai]);
                    return 0;
                }
                ai ++;
            }
        }
        ci ++;
        if(ci == midIndex)
        {
            printf("%ld", tmpd);
            return 0;
        }
    }
    for(;ai < an; ai ++)
    {
        ci++;
        if(ci == midIndex)
        {
            printf("%ld", a[ai]);
            return 0;
        }
    }
}
```

### 1030 Travel Plan (30point(s))

简单题，深搜+剪枝，记录当前的dis和cost和全局的dis和cost即可。

类似1003，不会Dijkstra所以没用。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <climits>

using namespace std;

int dis[500][500], cost[500][500], n, m, s, d;
bool visit[500];

vector<int> froad;
vector<int> troad;

int fdis=INT_MAX, tdis=0, fcost=INT_MAX, tcost=0;

void dfs(int start)
{
    visit[start] = true;
    // printf("visit %d\n", start);
    troad.push_back(start);
    if(start == d)
    {
        if(tdis < fdis)
        {
            fdis = tdis;
            fcost = tcost;
            froad.clear();
            froad.assign(troad.begin(), troad.end());
        } else if(tdis == fdis && tcost < fcost)
        {
            fcost = tcost;
            froad.clear();
            froad.assign(troad.begin(), troad.end());
        }
        visit[start] = false;
        troad.pop_back();
        return;
    }
    for(int i = 0; i < n; i ++)
    {
        if(dis[start][i] != 0 && visit[i] == false)
        {
            tdis += dis[start][i];
            if(tdis > fdis)
            {
                tdis -= dis[start][i];
                continue;
            }
            tcost += cost[start][i];
            dfs(i);
            tcost -= cost[start][i];
            tdis -= dis[start][i];
        }
    }
    visit[start] = false;
    troad.pop_back();
    return;
}

int main()
{
    scanf("%d %d %d %d", &n, &m, &s, &d);
    for(int i = 0; i < m; i ++)
    {
        int a, b, t, c;
        scanf("%d %d %d %d", &a, &b, &t, &c);
        dis[a][b] = t;
        dis[b][a] = t;
        cost[a][b] = c;
        cost[b][a] = c;
    }
    dfs(s);
    for(int i = 0; i < froad.size(); i ++)
    {
        printf("%d ", froad[i]);
    }
    printf("%d %d", fdis, fcost);
    return 0;
}
```

### 1031 Hello World for U (20point(s))

环形输出字符串，不是很难，主要就是算准就行。解析 by 柳神：

![2020-02-247.00.21.png](https://img.guoziyang.top/images/2020/02/24/2020-02-247.00.21.png)

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <string>

using namespace std;

int main()
{
    string str;
    cin >> str;
    int N = str.length();
    int n2 = (N+2)/3+(N+2)%3;
    int n1 = (N+2)/3;
    int spnum = n2-2;
    for(int i = 0; i < n1-1; i ++)
    {
        printf("%c", str[i]);
        for(int j = 0; j < spnum; j ++)
        {
            printf(" ");
        }
        printf("%c\n", str[N-i-1]);
    }
    for(int i = 0; i < n2; i ++)
    {
        printf("%c", str[n1-1+i]);
    }
    printf("\n");
    return 0;
}
```

### 1032 Sharing (25point(s))

求双链表的最长公共后缀，不难，用一个vector记录两个链表的地址，然后都从后面向前查找即可，注意处理长度为0的情况。

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

struct node
{
    char data;
    int next;
};

node nodes[100000];

int main()
{
    int abegin, bbegin, n;
    scanf("%d %d %d", &abegin, &bbegin, &n);
    for(int i = 0; i < n; i ++)
    {
        int ad, next;
        char data;
        scanf("%d %c %d", &ad, &data, &next);
        nodes[ad].data = data;
        nodes[ad].next = next;
    }
    vector<int> a, b;
    int ad = abegin;
    while(ad != -1)
    {
        a.push_back(ad);
        ad = nodes[ad].next;
    }
    int bd = bbegin;
    while(bd != -1)
    {
        b.push_back(bd);
        bd = nodes[bd].next;
    }
    if(a.size() == 0 || b.size() == 0 || a[a.size()-1] != b[b.size()-1])
    {
        printf("-1");
        return 0;
    }
    int res = a[a.size()-1], aindex=a.size()-2, bindex=b.size()-2;
    if(aindex == -1 || bindex == -1)
    {
        printf("%05d", res);
        return 0;
    }
    while(a[aindex] == b[bindex])
    {
        res = a[aindex];
        aindex --;
        bindex --;
        if(aindex == -1) break;
        if(bindex == -1) break;
    }
    printf("%05d", res);
    return 0;
}
```

### 1033 To Fill or Not to Fill (25point(s))

贪心算法，之前算法设计与分析的期末考过这题，了解算法之后就不难。

贪⼼思想：

1. 寻找比自己远的，能够到达的最大距离之间的加油站，如果找到了更低价格的油价，就加油至刚好到那个加油站距离的油，去那个加油站即可。

2. 如果找不到更低的（比当前站的油价低），就找尽可能低油价的加油站，在当前加油站加满油后过去。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>

using namespace std;

struct node
{
    double dis;
    double price;
};

bool cmp(node a, node b)
{
    return a.dis < b.dis;
}

int main()
{
    double davg, cmax, d;
    int n;
    scanf("%lf %lf %lf %d", &cmax, &d, &davg, &n);
    vector<node> stations(n+1);
    for(int i = 0; i < n; i ++)
    {
        scanf("%lf %lf", &stations[i].price, &stations[i].dis);
    }
    stations[n].dis = d;
    stations[n].price = 0.0;
    sort(stations.begin(), stations.end(), cmp);
    if(stations[0].dis != 0)
    {
        printf("The maximum travel distance = 0.00");
        return 0;
    }
    double cDis = 0.0, maxDis = 0.0, leftDis=0.0;
    double cPrice = stations[0].price;
    double totalPrice = 0.0;
    double cc = 0.0;
    while(cDis < d)
    {
        maxDis = cDis + cmax * davg;
        double minPriceDis = 0.0, minPrice = 999999.9;
        bool flag = false;
        for(int i = 1; i <= n && stations[i].dis <= maxDis; i ++)
        {
            if(stations[i].dis <= cDis) continue;
            if(stations[i].price < cPrice)
            {
                totalPrice += (stations[i].dis - cDis - leftDis) * cPrice / davg;
                leftDis = 0.0;
                cPrice = stations[i].price;
                cDis = stations[i].dis;
                flag = 1;
                break;
            }
            if(stations[i].price < minPrice)
            {
                minPrice = stations[i].price;
                minPriceDis = stations[i].dis;
            }
        }
        if(flag == false && minPrice != 999999.9)
        {
            totalPrice += (cPrice * (cmax - leftDis/davg));
            leftDis = cmax * davg - (minPriceDis - cDis);
            cPrice = minPrice;
            cDis = minPriceDis;
        }
        if(flag == 0 && minPrice == 999999.9)
        {
            cDis += cmax * davg;
            printf("The maximum travel distance = %.2f", cDis);
            return 0;
        }
    }
    printf("%.2lf", totalPrice);
    return 0;
}
```

### 1034 Head of a Gang (30分)

代码写得较长的一题，实际上不难。

本质上是对有环的、不（一定）连通的图的遍历，注意到有环就行。最后有一个坑点，就是需要将头头的名字按照字母顺序输出，否则测试点2、5会不通过。

```cpp
#include <cstdio>
#include <string>
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

using namespace std;

int n, k, p;
int rel[2000][2000];
map<string, int> ids;
map<int, string> names;
vector<vector<int> > gangs;
vector<int> tmpgangs;
int tmpw = 0;
bool visit[2000];

int cindex = -1;

int getIds(string name)
{
    if(ids.find(name) == ids.end())
    {
        cindex ++;
        ids[name] = cindex;
        names[cindex] = name;
        return cindex;
    }
    return ids[name];
}

void dfs(int start, int last)
{
    visit[start] = true;
    // cout << "add " << names[start] << " w is " << tmpw << endl;
    tmpgangs.push_back(start);
    for(int i = 0; i < p; i ++)
    {
        if(rel[start][i] != 0 && visit[i] == false)
        {
            tmpw += rel[start][i];
            dfs(i, start);
        } else if(rel[start][i] != 0 && i != last)
        {
            tmpw += rel[start][i];
        }
    }
}

int getW(int a)
{
    int total = 0;
    for(int i = 0; i < p; i ++)
    {
        if(rel[a][i] != 0 && i != a)
        {
            total += rel[a][i];
        }
    }
    return total;
}

int cmp(pair<string, int> a, pair<string, int> b)
{
    return a.first < b.first;
}

int main()
{
    scanf("%d %d", &n, &k);
    for(int i = 0; i < n; i ++)
    {
        string as, bs;
        int w;
        cin >> as >> bs >> w;
        int a = getIds(as);
        int b = getIds(bs);
        rel[a][b] += w;
        rel[b][a] += w;
    }
    p = ids.size();
    for(int i = 0; i < p; i ++)
    {
        if(visit[i] == false)
        {
            tmpgangs.clear();
            tmpw = 0;
            dfs(i, -1);
            if(tmpw > k && tmpgangs.size() > 2)
            {
                vector<int> tmp;
                tmp.assign(tmpgangs.begin(), tmpgangs.end());
                gangs.push_back(tmp);
            }
        }
    }
    printf("%lu\n", gangs.size());
    map<string, int> res;
    for(int i = 0; i < gangs.size(); i ++)
    {
        int maxI = -1, max = -1;
        vector<int> tmp = gangs[i];
        for(int j = 0; j < tmp.size(); j ++)
        {
            int tmpm = getW(tmp[j]);
            if(tmpm > max)
            {
                max = tmpm;
                maxI = j;
            }
        }
        res[names[tmp[maxI]]] = tmp.size();
    }
    vector<pair<string, int> > ress(res.begin(), res.end());
    sort(ress.begin(), ress.end(), cmp);
    for(int i = 0; i < ress.size(); i ++)
    {
        cout << ress[i].first << " " << ress[i].second << endl;
    }
    return 0;
}
```

### 1035 Password (20分)

题目不难，坑很让人无奈。

主要的坑就是如果没有修改任何account的话，需要输出一句话，总数是1和大于1输出的话是不一样的，is和are啊，account和accounts啊，主要还是得好好读题啊。

另外，`make_pair()`方法可以创建一个pair，很好用。

```cpp
#include <cstdio>
#include <algorithm>
#include <string>
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main()
{

    int n;
    scanf("%d", &n);
    vector<pair<string, string> > res;
    for(int i = 0; i < n; i ++)
    {
        string name, tmp;
        cin >> name >> tmp;
        int len = tmp.size();
        bool flag = false;
        for(int i = 0; i < len; i ++)
        {
            if(tmp[i] == '1') {tmp[i] = '@'; flag = true;}
            if(tmp[i] == '0') {tmp[i] = '%'; flag = true;}
            if(tmp[i] == 'l') {tmp[i] = 'L'; flag = true;}
            if(tmp[i] == 'O') {tmp[i] = 'o'; flag = true;}
        }
        if(flag) res.push_back(make_pair(name, tmp));
    }
    if(res.size() == 0)
    {
        if(n == 1) printf("There is 1 account and no account is modified");
        else printf("There are %d accounts and no account is modified", n);
    } else {
        printf("%lu\n", res.size());
        for(int i = 0; i < res.size(); i ++)
        {
            cout << res[i].first << " " << res[i].second << endl;
        }
    }
    return 0;
}
```

### 1036 Boys vs Girls (25分)

找出得分最高的女生和得分最低的男生，计算出得分的差，很简单，女生的得分不一定比男生高，注意绝对值。

```cpp
#include <vector>
#include <cstdio>
#include <string>
#include <iostream>
#include <algorithm>
#include <cmath>

using namespace std;

struct stu
{
    string name;
    bool male;
    string id;
    int grade;
};

bool cmp(stu a, stu b)
{
    return a.grade > b.grade;
}

int main()
{
    int n;
    scanf("%d", &n);
    vector<stu> stus(n);
    bool hasM=false, hasF=false;
    for(int i = 0; i < n; i ++)
    {
        char gen;
        cin >> stus[i].name;
        cin >> gen;
        if(gen == 'M')
        {
            stus[i].male = true;
            hasM = true;
        }
        else 
        {
            stus[i].male = false;
            hasF = true;
        }
        cin >> stus[i].id >> stus[i].grade;
    }
    sort(stus.begin(), stus.end(), cmp);
    int m, f;
    if(!hasF)
    {
        printf("Absent\n");
    } else {
        for(int i = 0; i < n; i ++)
        {
            if(stus[i].male == false)
            {
                cout << stus[i].name << " " << stus[i].id << endl;
                f = stus[i].grade;
                break;
            }
        }
    }
    if(!hasM)
    {
        printf("Absent\n");
    } else {
        for(int i = n-1; i >= 0; i --)
        {
            if(stus[i].male == true)
            {
                cout << stus[i].name << " " << stus[i].id << endl;
                m = stus[i].grade;
                break;
            }
        }
    }
    if(hasM == false || hasF == false)
    {
        printf("NA\n");
    } else {
        printf("%d", abs(m-f));
    }
    return 0;
}
```

### 1037 Magic Coupon (25分)

贪心算法的应用，排序，将最大正数之间相乘，最小的负数之间相乘即可

```cpp
#include <cstdio>
#include <algorithm>
#include <vector>

using namespace std;

bool cmp(int a, int b)
{
    return a > b;
}

int main()
{
    int na, nb;
    scanf("%d", &na);
    vector<int> a(na);
    for(int i = 0; i < na; i ++)
    {
        scanf("%d", &a[i]);
    }
    scanf("%d", &nb);
    vector<int> b(nb);
    for(int i = 0; i < nb; i ++)
    {
        scanf("%d", &b[i]);
    }
    sort(a.begin(), a.end(), cmp);
    sort(b.begin(), b.end(), cmp);
    int ai, bi;
    int total=0;
    for(ai=0,bi=0; ai<na,bi<nb; ai++,bi++)
    {
        if(a[ai] > 0 && b[bi] > 0)
        {
            total += a[ai]*b[bi];
        } else {
            break;
        }
    }
    for(ai=na-1,bi=nb-1; ai>-1,bi>-1; ai--,bi--)
    {
        if(a[ai] < 0 && b[bi] < 0)
        {
            total += a[ai]*b[bi];
        } else {
            break;
        }
    }
    printf("%d", total);
    return 0;
}
```

### 1038 Recover the Smallest Number (30point(s))

目前为止最让我叹为观止的一题。真心没想到sort还能这么用……，柳神就是柳神啊……

```cpp
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <sstream>

using namespace std;

bool cmp(string a, string b)
{
    return a+b < b+a;
}

int main()
{
    int n;
    cin >> n;
    vector<string> ss(n);
    for (int i = 0; i < n; i++)
    {
        cin >> ss[i];
    }
    sort(ss.begin(), ss.end(), cmp);
    string s="";
    for(int i = 0; i < n; i ++)
    {
        s += ss[i];
    }
    while(s.length() != 0 && s[0] == '0')
    {
        s.erase(s.begin());
    }
    if(s.length() == 0) cout << 0;
    else cout << s;
    return 0;
}
```

### 1039 Course List for Student (25分)

很屑的一题，展现了iostream的不好。

该题使用cout、cin、string则最后一个测试点必超时，需要用char数组，也可以转化为int（hash），最后注意一下课程编号要递增输出。

```cpp
#include <cstdio>
#include <string>
#include <iostream>
#include <algorithm>
#include <vector>
#include <map>

using namespace std;

map<int, vector<int> > cs;

int getid(char *name)
{
    int res=0;
    for(int i = 0; i < 3; i ++)
    {
        res = 26*res + (name[i]-'A');
    }
    res = res * 10 + name[3]-'0';
    return res;
}

void put(int name, int c)
{
    if(cs.find(name) == cs.end())
    {
        vector<int> tmp;
        tmp.push_back(c);
        cs[name] = tmp;
    }
    else
    {
        cs[name].push_back(c);
    }
}

int main()
{
    int n, k;
    scanf("%d %d", &n, &k);
    for(int i = 0; i < k; i ++)
    {
        int number, ps;
        scanf("%d %d", &number, &ps);
        for(int j = 0; j < ps; j ++)
        {
            char name[5];
            scanf("%s", name);
            int id = getid(name);
            put(id, number);
        }
    }
    for(int i = 0; i < n; i ++)
    {
        char name[5];
        scanf("%s", name);
        printf("%s ", name);
        int id = getid(name);
        auto it = cs.find(id);
        if(it == cs.end())
        {
            printf("0\n");
            continue;
        }
        else
        {
            vector<int> tmp = (*it).second;
            sort(tmp.begin(), tmp.end());
            printf("%d", tmp.size());
            for(int j = 0; j < tmp.size(); j ++)
            {
                printf(" %d", tmp[j]);
            }
            printf("\n");
        }
    }
    return 0;
}
```

### 1040 Longest Symmetric String (25分)

找最长的回文字串的题目，典型的动态规划题。

注意读入字符串的时候需要按行读。

```cpp
#include <cstdio>
#include <string>
#include <iostream>

using namespace std;

int tmp[1001][1001];

int main()
{
    string str;
    getline(cin, str, '\n');
    int len = str.size();
    int longest = 1;
    for(int i = 0; i < len; i ++)
    {
        tmp[i][i] = 1;
    }
    for(int i = 0; i < len-1; i ++)
    {
        if(str[i] == str[i+1])
        {
            tmp[i][i+1] = 1;
            longest = 2;
        }
        else
        {
            tmp[i][i+1] = 0;
        }
    }
    for(int i = 3; i <= len; i ++)
    {
        for(int j = 0; j <= len-i; j ++)
        {
            int a = j;
            int b = a+i-1;
            if(tmp[a+1][b-1] == 0) tmp[a][b] = 0;
            else
            {
                if(str[a] == str[b])
                {
                    tmp[a][b] = 1;
                    longest = i;
                } else {
                    tmp[a][b] = 0;
                }
            }
        }
    }
    printf("%d", longest);
    return 0;
}
```

### 1041 Be Unique (20分)

寻找一个序列中只出现一次的数，不应使用find，否则会超时。

```cpp
#include <cstdio>
#include <algorithm>
#include <map>
#include <vector>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    int a[10001];
    fill(a, a+10001, -1);
    vector<int> b;
    for(int i = 0; i < n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        if(a[tmp] == -1)
        {
            b.push_back(tmp);
            a[tmp] = 0;
        }
        a[tmp] ++;
    }
    for(int i = 0; i < n; i ++)
    {
        if(a[b[i]] == 1)
        {
            printf("%d", b[i]);
            return 0;
        }
    }
    printf("None");
    return 0;
}
```