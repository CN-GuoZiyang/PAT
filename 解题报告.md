### 1001 A+B Format (20分)

格式化字符串，要求隔三位按逗号分隔。

使用std::to_string可将数字转化为字符串，在输出时可直接将字符串看作和C一样的字符出租按下标索引。

输出时注意到，除却负号和最后一个字符外，每一个len-i模3余1的字符后都需要输出逗号。

```cpp
#include <cstdio>
#include <string>
using namespace std;

int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    string sumStr = to_string(a + b);
    int len = sumStr.length();
    for(int i = 0; i < len; i ++)
    {
        printf("%c", sumStr[i]);
        if(sumStr[i] == '-') continue;
        if((len - i)%3 == 1 && i != len - 1) printf(",");
    }
    return 0;
}
```

### 1002 A+B for Polynomials

这题用cpp重写之后不知道为什么写复杂了……

将两个多项式相加，Java党很自然地想到使用HashMap，C++里的map是基于红黑树的，查询速度也很快！

由于输出的时候需要按照指数排序，也就是按照map的key从大到小排序，而map是个无序的集合，所以需要将map转存在vector里，vector是动态数组。map里的每一个元素为一个pair，如map\<int, double\>的元素就说pair\<int, double\>，转存在vector后即可使用std::sort进行排序。每一个pair的first就是键，second就是值。

需要注意的是，使用std::sort排序的时候，需要导入algorithm包。在我的mac下使用g++时无需导包，但是PAT会编译错误。

另外，在判断double数值是否为0时需要引入误差，还需要首先计算绝对值再和误差比较。注意注意！

```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int cmp(pair<int, double> &a, pair<int, double> &b)
{
    return a.first > b.first;
}

int main()
{
    map<int, double> exps;
    for(int i = 0; i < 2; i ++)
    {
        int n;
        scanf("%d", &n);
        for(int j = 0; j < n; j ++)
        {
            int exp; double co;
            scanf("%d %lf", &exp, &co);
            if(exps.find(exp) != exps.end()) {
                exps[exp] += co;
            } else {
                exps[exp] = co;
            }
        }
    }
    vector<pair<int, double> > vecs(exps.begin(), exps.end());
    sort(vecs.begin(), vecs.end(), cmp);
    int len = 0;
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) len ++;
    }
    printf("%d", len);
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) printf(" %d %.1f", vecs[i].first, vecs[i].second);
    }
    return 0;
}
```