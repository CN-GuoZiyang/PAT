### 1001 A+B Format (20分)

格式化字符串，要求隔三位按逗号分隔。

使用`std::to_string`可将数字转化为字符串，在输出时可直接将字符串看作和C一样的字符出租按下标索引。

输出时注意到，除却负号和最后一个字符外，每一个len-i模3余1的字符后都需要输出逗号。

```cpp
#include <cstdio>
#include <string>
using namespace std;

int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    string sumStr = to_string(a + b);
    int len = sumStr.length();
    for(int i = 0; i < len; i ++)
    {
        printf("%c", sumStr[i]);
        if(sumStr[i] == '-') continue;
        if((len - i)%3 == 1 && i != len - 1) printf(",");
    }
    return 0;
}
```

### 1002 A+B for Polynomials

这题用cpp重写之后不知道为什么写复杂了……

将两个多项式相加，Java党很自然地想到使用HashMap，C++里的map是基于红黑树的，查询速度也很快！

由于输出的时候需要按照指数排序，也就是按照map的key从大到小排序，而map是个无序的集合，所以需要将map转存在vector里，vector是动态数组。map里的每一个元素为一个pair，如map\<int, double\>的元素就说pair\<int, double\>，转存在vector后即可使用`std::sort`进行排序。每一个pair的first就是键，second就是值。

需要注意的是，使用`std::sort`排序的时候，需要导入`algorithm`包。在我的mac下使用g++时无需导包，但是PAT会编译错误。

另外，在判断double数值是否为0时需要引入误差，还需要首先计算绝对值再和误差比较。注意注意！

```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int cmp(pair<int, double> &a, pair<int, double> &b)
{
    return a.first > b.first;
}

int main()
{
    map<int, double> exps;
    for(int i = 0; i < 2; i ++)
    {
        int n;
        scanf("%d", &n);
        for(int j = 0; j < n; j ++)
        {
            int exp; double co;
            scanf("%d %lf", &exp, &co);
            if(exps.find(exp) != exps.end()) {
                exps[exp] += co;
            } else {
                exps[exp] = co;
            }
        }
    }
    vector<pair<int, double> > vecs(exps.begin(), exps.end());
    sort(vecs.begin(), vecs.end(), cmp);
    int len = 0;
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) len ++;
    }
    printf("%d", len);
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) printf(" %d %.1f", vecs[i].first, vecs[i].second);
    }
    return 0;
}
```

### 1003 Emergency (25分)

这一题涉及了深搜，但是柳神貌似是用Dijkstra做的，有空可以看看Dijkstra怎么寻找多条最短路径吧。

深搜就比较简单了，无脑暴力搜索即可。注意点在于在从某个节点退出的时候，记得减去路径长度和救援队数。

最后一个测试点如果直接搜索的话时间可能较长，用c++没有超时（154ms，又不是不能用），用Java之类的估计就超了，可以考虑剪枝，遍历到加上路径长度大于当前最小路径长度的节点的时候直接跳过，这样可以把时间减到7ms。

```cpp
#include <cstdio>
#include <vector>
#include <climits>
#include <algorithm>

using namespace std;

int n, m, c1, c2;
vector<int> teams;
vector<bool> visited(500, false);
int road[500][500];

int paths = 0;
int length = INT_MAX;
int tmpLength = 0;
int res = -1;
int tmpRes = 0;

void dfs(int start)
{
    tmpRes += teams[start];
    if(start == c2)
    {
        if(tmpLength < length)
        {
            length = tmpLength;
            paths = 1;
            res = tmpRes;
        } else if(tmpLength == length)
        {
            paths ++;
            if(tmpRes > res) res = tmpRes;
        }
        tmpRes -= teams[start];
        return;
    }
    visited[start] = true;
    for(int i = 0; i < n; i ++)
    {
        if(visited[i] == false && road[start][i] != 0)
        {
            tmpLength += road[start][i];
            if(tmpLength > length)
            {
                tmpLength -= road[start][i];
                continue;
            }
            dfs(i);
            tmpLength -= road[start][i];
        }
    }
    visited[start] = false;
    tmpRes -= teams[start];
    return;
}

int main()
{
    scanf("%d %d %d %d", &n, &m, &c1, &c2);
    for(int i = 0; i < n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        teams.push_back(tmp);
    }
    for(int i = 0; i < m; i ++)
    {
        int a, b, l;
        scanf("%d %d %d", &a, &b, &l);
        road[a][b] = l;
        road[b][a] = l;
    }
    dfs(c1);
    printf("%d %d", paths, res);
    return 0;
}
```

### 1004 Counting Leaves (30分)

主要是树的层序遍历，可以使用队列queue，也可以自己写数组模拟队列。

注意一下，各个容器（如vector和queue）中的`empty()`方法不是清空该容器，而是返回一个bool值，用来判断该容器是否为空，这一点和Java很不一样。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int n, m;

struct node {
    vector<int> children;
};

int main()
{
    scanf("%d %d", &n, &m);
    vector<node> nodes(n+1);
    for(int i = 0; i < m; i ++)
    {
        int id, k;
        scanf("%d %d", &id, &k);
        for(int j = 0; j < k; j ++)
        {
            int tmp;
            scanf("%d", &tmp);
            nodes[id].children.push_back(tmp);
        }
    }
    queue<int> q;
    q.push(1);
    vector<int> reses;
    while(q.empty() == false)
    {
        vector<int> layer;
        while(q.size() != 0)
        {
            layer.push_back(q.front());
            q.pop();
        }
        int res = 0;
        for(int i = 0; i < layer.size(); i ++)
        {
            int index = layer[i];
            if(nodes[index].children.size() == 0)
            {
                res ++;
            } else {
                for(int j = 0; j < nodes[index].children.size(); j ++)
                {
                    q.push(nodes[index].children[j]);
                }
            }
        }
        reses.push_back(res);
    }
    for(int i = 0; i < reses.size(); i ++)
    {
        if(i == reses.size() - 1)
        {
            printf("%d", reses[i]);
        } else {
            printf("%d ", reses[i]);
        }
    }
    return 0;
}
```

### 1005 Spell It Right (20分)

总体是个水题，主要就是考察一下输入输出和字符串的运用，比较坑的是，所有的测试用例最后貌似都会有一个回车符，直接用`while(scanf("%c", &tmp) != EOF)`会读进去，得排除掉。

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    char tmp;
    int sum = 0;
    while(scanf("%c", &tmp) != EOF)
    {
        if('0' <= tmp && tmp <= '9') sum += (tmp - '0');
    }
    string sumStr = to_string(sum);
    int len = sumStr.length();
    string numStr[] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
    cout << numStr[sumStr[0] - '0'];
    for(int i = 1; i < len; i ++)
    {
        cout << " " << numStr[sumStr[i] - '0'];
    }
    return 0;
}
```

### 1006 Sign In and Sign Out (25分)

水题，一边读一边把时间转成秒数，比较最后输出即可。

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    string in;
    int inTime = 23 * 3600 + 59 * 60 + 59 * 59;
    string out;
    int outTime = 0;
    for(int i = 0; i < n; i ++)
    {
        string tmp;
        int signin[3], signout[3];
        cin >> tmp;
        scanf("%d:%d:%d %d:%d:%d", &signin[0], &signin[1], &signin[2], &signout[0], &signout[1], &signout[2]);
        int signinSec = signin[0] * 3600 + signin[1] * 60 + signin[2];
        int signoutSec = signout[0] * 3600 + signout[1] * 60 + signout[2];
        if(signinSec < inTime) 
        {
            in = tmp;
            inTime = signinSec;
        }
        if(signoutSec > outTime)
        {
            out = tmp;
            outTime = signoutSec;
        }
    }
    cout << in << " " << out;
    return 0;
}
```

### 1007 Maximum Subsequence Sum (25分)

该题可以边读边判断。

记录一个临时的左侧和右侧坐标以及临时的和，不断读入新的数，如果读入的新的数让和小于0，就舍弃当前的临时值，将临时和置为0，并将临时左右侧放到下一个数的位置。否则就不断将数字读进来并与全局最大和对比，大于就更新。

对于全都是负数的情况，设置一个标志位并在最后判断标志即可。

```cpp
#include <cstdio>
#include <vector>

using namespace std;

int main()
{
    int k;
    scanf("%d", &k);
    int start=0, end=0, sum=-1;
    int tmpsum=0, tmpstart=0, tmpend=-1;
    bool allneg = true;
    vector<int> ints;
    for(int i = 0; i < k; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        ints.push_back(tmp);
        if(tmp >= 0) allneg = false;
        tmpsum += tmp;
        tmpend ++;
        if(tmpsum < 0)
        {
            tmpsum = 0;
            tmpstart = i+1;
            tmpend = i;
            continue;
        }
        if(tmpsum > sum)
        {
            start = tmpstart;
            end = tmpend;
            sum = tmpsum;
        }
    }
    if(allneg == true)
    {
        printf("0 %d %d", ints[0], ints[ints.size() - 1]);
        return 0;
    }
    printf("%d %d %d", sum, ints[start], ints[end]);
    return 0;
}
```

### 1008 Elevator (20分)

良心无坑水题，像是乙级的题目，唯一需要注意的是在每一层楼都需要停5秒，加上就行。

```cpp
#include <cstdio>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    int c = 0;
    int res = 0;
    for(int i = 0; i < n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        if(tmp == c) res += 5;
        else if(tmp > c)
        {
            res += ((tmp - c) * 6 + 5);
            c = tmp;
        } else
        {
            res += ((c - tmp) * 4 + 5);
            c = tmp;
        }
    }
    printf("%d", res);
    return 0;
}
```

### 1009 Product of Polynomials (25分)

该题类似于1002题，只不过变成了求多项式之积，基本思路一致。

多项式a可以先用一个map存储，待读入多项式b时，每读入一项就和多项式a逐项相乘，结果存入结果map中，再将结果map排序输出即可。

```cpp
#include <cstdio>
#include <vector>
#include <algorithm>
#include <cmath>
#include <map>

using namespace std;

bool cmp(pair<int, double> a, pair<int, double> b)
{
    return a.first > b.first;
}

int main()
{
    map<int, double> pa;
    map<int, double> res;
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        int exp;
        double co;
        scanf("%d %lf", &exp, &co);
        pa[exp] = co;
    }
    scanf("%d", &n);
    for(int i = 0; i < n; i ++)
    {
        int exp;
        double co;
        scanf("%d %lf", &exp, &co);
        for(auto it = pa.begin(); it != pa.end(); it ++)
        {
            int tmp = exp + it->first;
            auto tmpit = res.find(tmp);
            if(tmpit != res.end())
            {
                res[tmp] = res[tmp] + it->second * co;
            } else {
                res[tmp] = it->second * co;
            }
        }
    }
    vector<pair<int, double> > resv(res.begin(), res.end());
    sort(resv.begin(), resv.end(), cmp);
    int num = 0;
    for(int i = 0; i < resv.size(); i ++)
    {
        if(abs(resv[i].second) > 0.05) num ++;
    }
    printf("%d", num);
    for(int i = 0; i < resv.size(); i ++)
    {
        if(abs(resv[i].second) > 0.05) printf(" %d %.1f", resv[i].first, resv[i].second);
    }
    return 0;
}
```

### 1010 Radix (25分)

这题**很坑**！

给出两个数和其中一个数的进制，要求找出另一个数的进制，使两个数相等。

主要方法就是二分，但是这个题的细节点很多。二分的下限是未知数中出现的最大的数字符号，上限就是另一个数，这个比较简单。

在二分的过程中可能会由于数字过大导致溢出，溢出的数字就会变成负数，得按照过大处理。

两个数使用long long表示，已知数的进制不是很大，可以用int表示，但是未知数的进制可能超过int的表示范围，需要用long long，否则会有一个测试点不通过。

这题二刷的时候才给整对……

```cpp
#include <string>
#include <iostream>
#include <cmath>

using namespace std;

long long convert2Decimal(string num, int radix)
{
    int power = 0;
    long long res = 0;
    int len = num.length();
    for(int i = len-1; i >= 0; i --, power ++)
    {
        int tmp;
        if('0' <= num[i] && num[i] <= '9')
        {
            tmp = num[i] - '0';
        } else {
            tmp = num[i] - 'a' + 10;
        }
        res += (pow(radix, power) * tmp);
    }
    return res;
}

int judgeEqual(long long s, string t)
{
    long long min = -1;
    int len = t.length();
    for(int i = 0; i < len; i ++)
    {
        char tmp = t[i];
        if(tmp > min) min = tmp;
    }
    if('0' <= min && min <= '9') min -= '0';
    else min = min - 'a' + 10;
    min ++;
    long long max = s < min ? min : s;
    while(min <= max)
    {
        long long mid = (min + max) / 2;
        long long tmp = convert2Decimal(t, mid);
        if(tmp < 0 || tmp > s) max = mid - 1;
        else if(tmp == s) return mid;
        else min = mid + 1;
    }
    return -1;
}

int main()
{
    int tag, radix;
    string n1, n2;
    cin >> n1 >> n2 >> tag >> radix;
    long long res = -1;
    if(tag == 1)
    {
        long long tmp = convert2Decimal(n1, radix);
        res = judgeEqual(tmp, n2);
    } else {
        long long tmp = convert2Decimal(n2, radix);
        res = judgeEqual(tmp, n1);
    }
    if(res == -1) cout << "Impossible";
    else cout << res;
    return 0;
}
```

### 1011 World Cup Betting (20分)

简单题。好像是关于球赛什么的，具体啥也没怎么读懂，反正读进去找最大值套公式就行。

找最大值可以使用`algorithm`包下的`max_element()`函数，传入头和尾的指针，返回指向最大值的指针，需要取值运算(\*)取出最大值。

```cpp
#include <cstdio>
#include <algorithm>

using namespace std;

int main()
{
    double res[3];
    int wtl[3];
    char duiying[] = {'W', 'T', 'L'};
    for(int i = 0; i < 3; i ++)
    {
        double a[3];
        for(int j = 0; j < 3; j ++) scanf("%lf", &a[j]);
        res[i] = *max_element(a, a+3);
        if(res[i] == a[0]) wtl[i] = 0;
        else if(res[i] == a[1]) wtl[i] = 1;
        else wtl[i] = 2;
    }
    for(int i = 0; i < 3; i ++)
    {
        printf("%c ", duiying[wtl[i]]);
    }
    printf("%.2f", (res[0] * res[1] * res[2] * 0.65 - 1) * 2);
    return 0;
}
```