### 1001 A+B Format (20分)

格式化字符串，要求隔三位按逗号分隔。

使用std::to_string可将数字转化为字符串，在输出时可直接将字符串看作和C一样的字符出租按下标索引。

输出时注意到，除却负号和最后一个字符外，每一个len-i模3余1的字符后都需要输出逗号。

```cpp
#include <cstdio>
#include <string>
using namespace std;

int main()
{
    int a, b;
    scanf("%d %d", &a, &b);
    string sumStr = to_string(a + b);
    int len = sumStr.length();
    for(int i = 0; i < len; i ++)
    {
        printf("%c", sumStr[i]);
        if(sumStr[i] == '-') continue;
        if((len - i)%3 == 1 && i != len - 1) printf(",");
    }
    return 0;
}
```

### 1002 A+B for Polynomials

这题用cpp重写之后不知道为什么写复杂了……

将两个多项式相加，Java党很自然地想到使用HashMap，C++里的map是基于红黑树的，查询速度也很快！

由于输出的时候需要按照指数排序，也就是按照map的key从大到小排序，而map是个无序的集合，所以需要将map转存在vector里，vector是动态数组。map里的每一个元素为一个pair，如map\<int, double\>的元素就说pair\<int, double\>，转存在vector后即可使用std::sort进行排序。每一个pair的first就是键，second就是值。

需要注意的是，使用std::sort排序的时候，需要导入algorithm包。在我的mac下使用g++时无需导包，但是PAT会编译错误。

另外，在判断double数值是否为0时需要引入误差，还需要首先计算绝对值再和误差比较。注意注意！

```cpp
#include <cstdio>
#include <map>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int cmp(pair<int, double> &a, pair<int, double> &b)
{
    return a.first > b.first;
}

int main()
{
    map<int, double> exps;
    for(int i = 0; i < 2; i ++)
    {
        int n;
        scanf("%d", &n);
        for(int j = 0; j < n; j ++)
        {
            int exp; double co;
            scanf("%d %lf", &exp, &co);
            if(exps.find(exp) != exps.end()) {
                exps[exp] += co;
            } else {
                exps[exp] = co;
            }
        }
    }
    vector<pair<int, double> > vecs(exps.begin(), exps.end());
    sort(vecs.begin(), vecs.end(), cmp);
    int len = 0;
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) len ++;
    }
    printf("%d", len);
    for(int i = 0; i < vecs.size(); i ++)
    {
        if(abs(vecs[i].second) > 0.01) printf(" %d %.1f", vecs[i].first, vecs[i].second);
    }
    return 0;
}
```

### 1003 Emergency (25分)

这一题涉及了深搜，但是柳神貌似是用Dijkstra做的，有空可以看看Dijkstra怎么寻找多条最短路径吧。

深搜就比较简单了，无脑暴力搜索即可。注意点在于在从某个节点退出的时候，记得减去路径长度和救援队数。

最后一个测试点如果直接搜索的话时间可能较长，用c++没有超时（154ms，又不是不能用），用Java之类的估计就超了，可以考虑剪枝，遍历到加上路径长度大于当前最小路径长度的节点的时候直接跳过，这样可以把时间减到7ms。

```cpp
#include <cstdio>
#include <vector>
#include <climits>
#include <algorithm>

using namespace std;

int n, m, c1, c2;
vector<int> teams;
vector<bool> visited(500, false);
int road[500][500];

int paths = 0;
int length = INT_MAX;
int tmpLength = 0;
int res = -1;
int tmpRes = 0;

void dfs(int start)
{
    tmpRes += teams[start];
    if(start == c2)
    {
        if(tmpLength < length)
        {
            length = tmpLength;
            paths = 1;
            res = tmpRes;
        } else if(tmpLength == length)
        {
            paths ++;
            if(tmpRes > res) res = tmpRes;
        }
        tmpRes -= teams[start];
        return;
    }
    visited[start] = true;
    for(int i = 0; i < n; i ++)
    {
        if(visited[i] == false && road[start][i] != 0)
        {
            tmpLength += road[start][i];
            if(tmpLength > length)
            {
                tmpLength -= road[start][i];
                continue;
            }
            dfs(i);
            tmpLength -= road[start][i];
        }
    }
    visited[start] = false;
    tmpRes -= teams[start];
    return;
}

int main()
{
    scanf("%d %d %d %d", &n, &m, &c1, &c2);
    for(int i = 0; i < n; i ++)
    {
        int tmp;
        scanf("%d", &tmp);
        teams.push_back(tmp);
    }
    for(int i = 0; i < m; i ++)
    {
        int a, b, l;
        scanf("%d %d %d", &a, &b, &l);
        road[a][b] = l;
        road[b][a] = l;
    }
    dfs(c1);
    printf("%d %d", paths, res);
    return 0;
}
```

### 1004 Counting Leaves (30分)

主要是树的层序遍历，可以使用队列queue，也可以自己写数组模拟队列。

注意一下，各个容器（如vector和queue）中的empty()方法不是清空该容器，而是返回一个bool值，用来判断该容器是否为空，这一点和Java很不一样。

```cpp
#include <cstdio>
#include <vector>
#include <queue>
#include <algorithm>

using namespace std;

int n, m;

struct node {
    vector<int> children;
};

int main()
{
    scanf("%d %d", &n, &m);
    vector<node> nodes(n+1);
    for(int i = 0; i < m; i ++)
    {
        int id, k;
        scanf("%d %d", &id, &k);
        for(int j = 0; j < k; j ++)
        {
            int tmp;
            scanf("%d", &tmp);
            nodes[id].children.push_back(tmp);
        }
    }
    queue<int> q;
    q.push(1);
    vector<int> reses;
    while(q.empty() == false)
    {
        vector<int> layer;
        while(q.size() != 0)
        {
            layer.push_back(q.front());
            q.pop();
        }
        int res = 0;
        for(int i = 0; i < layer.size(); i ++)
        {
            int index = layer[i];
            if(nodes[index].children.size() == 0)
            {
                res ++;
            } else {
                for(int j = 0; j < nodes[index].children.size(); j ++)
                {
                    q.push(nodes[index].children[j]);
                }
            }
        }
        reses.push_back(res);
    }
    for(int i = 0; i < reses.size(); i ++)
    {
        if(i == reses.size() - 1)
        {
            printf("%d", reses[i]);
        } else {
            printf("%d ", reses[i]);
        }
    }
    return 0;
}
```

### 1005 Spell It Right (20分)

总体是个水题，主要就是考察一下输入输出和字符串的运用，比较坑的是，所有的测试用例最后貌似都会有一个回车符，直接用`while(scanf("%c", &tmp) != EOF)`会读进去，得排除掉。

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    char tmp;
    int sum = 0;
    while(scanf("%c", &tmp) != EOF)
    {
        if('0' <= tmp && tmp <= '9') sum += (tmp - '0');
    }
    string sumStr = to_string(sum);
    int len = sumStr.length();
    string numStr[] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
    cout << numStr[sumStr[0] - '0'];
    for(int i = 1; i < len; i ++)
    {
        cout << " " << numStr[sumStr[i] - '0'];
    }
    return 0;
}
```

### 1006 Sign In and Sign Out (25分)

水题，一边读一边把时间转成秒数，比较最后输出即可。

```cpp
#include <cstdio>
#include <iostream>
#include <string>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);
    string in;
    int inTime = 23 * 3600 + 59 * 60 + 59 * 59;
    string out;
    int outTime = 0;
    for(int i = 0; i < n; i ++)
    {
        string tmp;
        int signin[3], signout[3];
        cin >> tmp;
        scanf("%d:%d:%d %d:%d:%d", &signin[0], &signin[1], &signin[2], &signout[0], &signout[1], &signout[2]);
        int signinSec = signin[0] * 3600 + signin[1] * 60 + signin[2];
        int signoutSec = signout[0] * 3600 + signout[1] * 60 + signout[2];
        if(signinSec < inTime) 
        {
            in = tmp;
            inTime = signinSec;
        }
        if(signoutSec > outTime)
        {
            out = tmp;
            outTime = signoutSec;
        }
    }
    cout << in << " " << out;
    return 0;
}
```